{"version":3,"sources":["node_modules/gator/gator.js","Resources/Private/Assets/Scripts/matches.js","Resources/Private/Assets/Scripts/isNode.js","Resources/Private/Assets/Scripts/mobileMenu.js","Resources/Private/Assets/Scripts/domReady.js","Resources/Private/Assets/Scripts/bubbleUntil.js","Resources/Private/Assets/Scripts/focusWithin.js","Resources/Private/Assets/MobileMenu.js"],"names":["_matcher","_level","_id","_handlers","_gatorInstances","_matchesSelector","element","selector","boundElement","matches","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","Gator","matchesSelector","_getMatcher","call","parentNode","_addHandler","gator","event","callback","id","push","_removeHandler","i","length","splice","type","hasOwnProperty","_bind","events","remove","this","Array","addEvent","_getGlobalCallback","e","match","target","srcElement","j","matchesEvent","stopPropagation","cancelBubble","cancel","key","prototype","on","off","preventDefault","useCapture","addEventListener","module","exports","nodeType","warn","DEFAULTS","join","document","documentElement","body","menuOpen","focusWithin","isTouch","select","Object","assign","header","navigation","hamburger","focusable","focusableNav","menuIsOpen","submenuLinks","closeSubmenus","forEach","blur","checkSize","style","window","getComputedStyle","display","opacity","visibility","classList","contains","setTabIndexFromNavigationElements","enable","tabIndex","maintainFocus","focus","bindKeypress","which","escape","tab","index","indexOf","activeElement","shiftKey","triggerEvent","eventName","OPTIONS","CustomEvent","detail","createEvent","initCustomEvent","dispatchEvent","hideMenu","setIndex","scrollTo","parseInt","top","error","firstRun","runCallback","readyState","querySelector","querySelectorAll","openOnTap","htmlElement","pageYOffset","add","link","selectorOrElement","returnAll","IS_STRING","isNode","elements","bubbleUntil","cssClasses","opts","className","attr","force","lastElements","initialize","ignoredError","onfocuschange","lastElement","pop","removeAttribute","test","nodeName","setAttribute","load","removeEventListener","mobileMenu"],"mappings":"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","file":"MobileMenu.js","sourcesContent":["/**\n * Copyright 2014 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * GATOR.JS\n * Simple Event Delegation\n *\n * @version 1.2.4\n *\n * Compatible with IE 9+, FF 3.6+, Safari 5+, Chrome\n *\n * Include legacy.js for compatibility with older browsers\n *\n *             .-._   _ _ _ _ _ _ _ _\n *  .-''-.__.-'00  '-' ' ' ' ' ' ' ' '-.\n * '.___ '    .   .--_'-' '-' '-' _'-' '._\n *  V: V 'vv-'   '_   '.       .'  _..' '.'.\n *    '=.____.=_.--'   :_.__.__:_   '.   : :\n *            (((____.-'        '-.  /   : :\n *                              (((-'\\ .' /\n *                            _____..'  .'\n *                           '-._____.-'\n */\n(function() {\n    var _matcher,\n        _level = 0,\n        _id = 0,\n        _handlers = {},\n        _gatorInstances = {};\n\n    function _addEvent(gator, type, callback) {\n\n        // blur and focus do not bubble up but if you use event capturing\n        // then you will get them\n        var useCapture = type == 'blur' || type == 'focus';\n        gator.element.addEventListener(type, callback, useCapture);\n    }\n\n    function _cancel(e) {\n        e.preventDefault();\n        e.stopPropagation();\n    }\n\n    /**\n     * returns function to use for determining if an element\n     * matches a query selector\n     *\n     * @returns {Function}\n     */\n    function _getMatcher(element) {\n        if (_matcher) {\n            return _matcher;\n        }\n\n        if (element.matches) {\n            _matcher = element.matches;\n            return _matcher;\n        }\n\n        if (element.webkitMatchesSelector) {\n            _matcher = element.webkitMatchesSelector;\n            return _matcher;\n        }\n\n        if (element.mozMatchesSelector) {\n            _matcher = element.mozMatchesSelector;\n            return _matcher;\n        }\n\n        if (element.msMatchesSelector) {\n            _matcher = element.msMatchesSelector;\n            return _matcher;\n        }\n\n        if (element.oMatchesSelector) {\n            _matcher = element.oMatchesSelector;\n            return _matcher;\n        }\n\n        // if it doesn't match a native browser method\n        // fall back to the gator function\n        _matcher = Gator.matchesSelector;\n        return _matcher;\n    }\n\n    /**\n     * determines if the specified element matches a given selector\n     *\n     * @param {Node} element - the element to compare against the selector\n     * @param {string} selector\n     * @param {Node} boundElement - the element the listener was attached to\n     * @returns {void|Node}\n     */\n    function _matchesSelector(element, selector, boundElement) {\n\n        // no selector means this event was bound directly to this element\n        if (selector == '_root') {\n            return boundElement;\n        }\n\n        // if we have moved up to the element you bound the event to\n        // then we have come too far\n        if (element === boundElement) {\n            return;\n        }\n\n        // if this is a match then we are done!\n        if (_getMatcher(element).call(element, selector)) {\n            return element;\n        }\n\n        // if this element did not match but has a parent we should try\n        // going up the tree to see if any of the parent elements match\n        // for example if you are looking for a click on an <a> tag but there\n        // is a <span> inside of the a tag that it is the target,\n        // it should still work\n        if (element.parentNode) {\n            _level++;\n            return _matchesSelector(element.parentNode, selector, boundElement);\n        }\n    }\n\n    function _addHandler(gator, event, selector, callback) {\n        if (!_handlers[gator.id]) {\n            _handlers[gator.id] = {};\n        }\n\n        if (!_handlers[gator.id][event]) {\n            _handlers[gator.id][event] = {};\n        }\n\n        if (!_handlers[gator.id][event][selector]) {\n            _handlers[gator.id][event][selector] = [];\n        }\n\n        _handlers[gator.id][event][selector].push(callback);\n    }\n\n    function _removeHandler(gator, event, selector, callback) {\n\n        // if there are no events tied to this element at all\n        // then don't do anything\n        if (!_handlers[gator.id]) {\n            return;\n        }\n\n        // if there is no event type specified then remove all events\n        // example: Gator(element).off()\n        if (!event) {\n            for (var type in _handlers[gator.id]) {\n                if (_handlers[gator.id].hasOwnProperty(type)) {\n                    _handlers[gator.id][type] = {};\n                }\n            }\n            return;\n        }\n\n        // if no callback or selector is specified remove all events of this type\n        // example: Gator(element).off('click')\n        if (!callback && !selector) {\n            _handlers[gator.id][event] = {};\n            return;\n        }\n\n        // if a selector is specified but no callback remove all events\n        // for this selector\n        // example: Gator(element).off('click', '.sub-element')\n        if (!callback) {\n            delete _handlers[gator.id][event][selector];\n            return;\n        }\n\n        // if we have specified an event type, selector, and callback then we\n        // need to make sure there are callbacks tied to this selector to\n        // begin with.  if there aren't then we can stop here\n        if (!_handlers[gator.id][event][selector]) {\n            return;\n        }\n\n        // if there are then loop through all the callbacks and if we find\n        // one that matches remove it from the array\n        for (var i = 0; i < _handlers[gator.id][event][selector].length; i++) {\n            if (_handlers[gator.id][event][selector][i] === callback) {\n                _handlers[gator.id][event][selector].splice(i, 1);\n                break;\n            }\n        }\n    }\n\n    function _handleEvent(id, e, type) {\n        if (!_handlers[id][type]) {\n            return;\n        }\n\n        var target = e.target || e.srcElement,\n            selector,\n            match,\n            matches = {},\n            i = 0,\n            j = 0;\n\n        // find all events that match\n        _level = 0;\n        for (selector in _handlers[id][type]) {\n            if (_handlers[id][type].hasOwnProperty(selector)) {\n                match = _matchesSelector(target, selector, _gatorInstances[id].element);\n\n                if (match && Gator.matchesEvent(type, _gatorInstances[id].element, match, selector == '_root', e)) {\n                    _level++;\n                    _handlers[id][type][selector].match = match;\n                    matches[_level] = _handlers[id][type][selector];\n                }\n            }\n        }\n\n        // stopPropagation() fails to set cancelBubble to true in Webkit\n        // @see http://code.google.com/p/chromium/issues/detail?id=162270\n        e.stopPropagation = function() {\n            e.cancelBubble = true;\n        };\n\n        for (i = 0; i <= _level; i++) {\n            if (matches[i]) {\n                for (j = 0; j < matches[i].length; j++) {\n                    if (matches[i][j].call(matches[i].match, e) === false) {\n                        Gator.cancel(e);\n                        return;\n                    }\n\n                    if (e.cancelBubble) {\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * binds the specified events to the element\n     *\n     * @param {string|Array} events\n     * @param {string} selector\n     * @param {Function} callback\n     * @param {boolean=} remove\n     * @returns {Object}\n     */\n    function _bind(events, selector, callback, remove) {\n\n        // fail silently if you pass null or undefined as an alement\n        // in the Gator constructor\n        if (!this.element) {\n            return;\n        }\n\n        if (!(events instanceof Array)) {\n            events = [events];\n        }\n\n        if (!callback && typeof(selector) == 'function') {\n            callback = selector;\n            selector = '_root';\n        }\n\n        var id = this.id,\n            i;\n\n        function _getGlobalCallback(type) {\n            return function(e) {\n                _handleEvent(id, e, type);\n            };\n        }\n\n        for (i = 0; i < events.length; i++) {\n            if (remove) {\n                _removeHandler(this, events[i], selector, callback);\n                continue;\n            }\n\n            if (!_handlers[id] || !_handlers[id][events[i]]) {\n                Gator.addEvent(this, events[i], _getGlobalCallback(events[i]));\n            }\n\n            _addHandler(this, events[i], selector, callback);\n        }\n\n        return this;\n    }\n\n    /**\n     * Gator object constructor\n     *\n     * @param {Node} element\n     */\n    function Gator(element, id) {\n\n        // called as function\n        if (!(this instanceof Gator)) {\n            // only keep one Gator instance per node to make sure that\n            // we don't create a ton of new objects if you want to delegate\n            // multiple events from the same node\n            //\n            // for example: Gator(document).on(...\n            for (var key in _gatorInstances) {\n                if (_gatorInstances[key].element === element) {\n                    return _gatorInstances[key];\n                }\n            }\n\n            _id++;\n            _gatorInstances[_id] = new Gator(element, _id);\n\n            return _gatorInstances[_id];\n        }\n\n        this.element = element;\n        this.id = id;\n    }\n\n    /**\n     * adds an event\n     *\n     * @param {string|Array} events\n     * @param {string} selector\n     * @param {Function} callback\n     * @returns {Object}\n     */\n    Gator.prototype.on = function(events, selector, callback) {\n        return _bind.call(this, events, selector, callback);\n    };\n\n    /**\n     * removes an event\n     *\n     * @param {string|Array} events\n     * @param {string} selector\n     * @param {Function} callback\n     * @returns {Object}\n     */\n    Gator.prototype.off = function(events, selector, callback) {\n        return _bind.call(this, events, selector, callback, true);\n    };\n\n    Gator.matchesSelector = function() {};\n    Gator.cancel = _cancel;\n    Gator.addEvent = _addEvent;\n    Gator.matchesEvent = function() {\n        return true;\n    };\n\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Gator;\n    }\n\n    window.Gator = Gator;\n}) ();\n","export default function(element, selector) {\n    if (!element || typeof selector != \"string\" || element.nodeType != 1) {\n        console.warn(\"Wrong or missing arguments in function `matches`\");\n        return null;\n    }\n    return (\n        element.matches ||\n        element.matchesSelector ||\n        element.msMatchesSelector ||\n        element.mozMatchesSelector ||\n        element.webkitMatchesSelector ||\n        element.oMatchesSelector\n    ).call(element, selector);\n}\n","export default function(element) {\n    return element.nodeType == 1;\n}\n","import Gator from \"gator\";\nimport domReady from \"./domReady\";\nimport focusWithinFunc from \"./focusWithin\";\nimport bubbleUntil from \"./bubbleUntil\";\n\nconst DEFAULTS = {\n    key: {\n        tab: 9,\n        escape: 27\n    },\n    selector: {\n        header: \".page-header\",\n        navigation: \".page-navigation\",\n        hamburger: \".hamburger-icon\",\n        focusable: [\n            \"a[href]\",\n            \"area[href]\",\n            \"input:not([disabled])\",\n            \"select:not([disabled])\",\n            \"textarea:not([disabled])\",\n            \"button:not([disabled])\",\n            \"iframe\",\n            \"object\",\n            \"embed\",\n            \"[contenteditable]\",\n            \"[tabindex]:not([tabindex^='-'])\"\n        ].join(\",\"),\n        openOnTap: \".nav-element.-hassub > a.nav-link.-level1\"\n    },\n    menuOpen: \"-menuopen\",\n    htmlElement: document.documentElement,\n    body: document.body,\n    isTouch: \"ontouchstart\" in document.documentElement,\n    focusWithin: document\n};\n\nexport default function({\n    selector = {},\n    menuOpen = DEFAULTS.menuOpen,\n    focusWithin = DEFAULTS.focusWithin,\n    isTouch = DEFAULTS.isTouch\n} = {}) {\n    let select = Object.assign({}, DEFAULTS.selector, selector);\n    let header;\n    let navigation;\n    let hamburger;\n    let focusable = [];\n    let focusableNav = [];\n    let menuIsOpen = false;\n    let submenuLinks = [];\n\n    onReady();\n    addGatorEvents();\n\n    if (focusWithin) {\n        focusWithinFunc(focusWithin);\n    }\n\n    function onReady() {\n        domReady(() => {\n            if (DEFAULTS.body.classList.contains(menuOpen)) {\n                menuIsOpen = true;\n            }\n            header = document.querySelector(select.header);\n\n            if (header) {\n                hamburger = header.querySelector(select.hamburger);\n                navigation = header.querySelector(select.navigation);\n                focusable = [...header.querySelectorAll(select.focusable)];\n                if (navigation) {\n                    focusableNav = [\n                        ...navigation.querySelectorAll(select.focusable)\n                    ];\n\n                    if (select.openOnTap && isTouch) {\n                        submenuLinks = [\n                            ...navigation.querySelectorAll(select.openOnTap)\n                        ];\n                    }\n                }\n                checkSize();\n            }\n        });\n    }\n\n    function addGatorEvents() {\n        Gator(window).on(\"resize\", checkSize);\n        Gator(DEFAULTS.htmlElement).on(\"click\", select.hamburger, function() {\n            toggleMenu();\n            this.blur();\n        });\n\n        if (select.openOnTap && isTouch) {\n            Gator(DEFAULTS.htmlElement).on(\"touchend\", function(event) {\n                if (!menuIsOpen) {\n                    let link = bubbleUntil(event.target, select.openOnTap);\n                    if (link) {\n                        if (\n                            !link.parentNode.classList.contains(\n                                cssClasses.focus\n                            )\n                        ) {\n                            event.preventDefault();\n                            event.stopPropagation();\n                            closeSubmenus();\n                            setTimeout(() => {\n                                link.focus();\n                            }, 0);\n                        }\n                    } else {\n                        closeSubmenus();\n                    }\n                }\n            });\n        }\n    }\n\n    function closeSubmenus() {\n        submenuLinks.forEach(link => {\n            link.blur();\n        });\n    }\n\n    function checkSize() {\n        if (hamburger) {\n            let style = window.getComputedStyle(hamburger);\n            if (\n                style.display == \"none\" ||\n                style.opacity == \"0\" ||\n                style.visibility == \"hidden\"\n            ) {\n                hideMenu(false);\n                setTabIndexFromNavigationElements(true);\n            } else if (!DEFAULTS.body.classList.contains(menuOpen)) {\n                setTabIndexFromNavigationElements(false);\n            }\n        }\n    }\n\n    function setTabIndexFromNavigationElements(enable) {\n        focusableNav.forEach(element => {\n            element.tabIndex = enable ? 0 : -1;\n        });\n    }\n\n    function maintainFocus(event) {\n        // If the menu is shown and the focus is not within the header,\n        // move it back to its first focusable child\n        if (menuIsOpen && !header.contains(event.target) && focusable.length) {\n            focusable[0].focus();\n        }\n    }\n\n    function bindKeypress(event) {\n        if (menuIsOpen) {\n            // If ESCAPE key is being pressed, prevent any further\n            // effects from the ESCAPE key and hide the Menu\n\n            if (event.which === DEFAULTS.key.escape) {\n                event.preventDefault();\n                hideMenu();\n            }\n\n            // If TAB key is being pressed, make sure the\n            // focus stays trapped within the menu\n            if (event.which === DEFAULTS.key.tab) {\n                trapTabKey(event);\n            }\n        }\n    }\n\n    function trapTabKey(event) {\n        let index = focusable.indexOf(document.activeElement);\n\n        // If the SHIFT key is being pressed while tabbing (moving backwards) and\n        // the currently focused item is the first one, move the focus to the last\n        // focusable item from the menu\n        if (event.shiftKey && index === 0) {\n            focusable[focusable.length - 1].focus();\n            event.preventDefault();\n\n            // If the SHIFT key is not being pressed (moving forwards) and the\n            // currently focused item is the last one, move the focus to the\n            // first focusable item from the menu\n        } else if (!event.shiftKey && index === focusable.length - 1) {\n            focusable[0].focus();\n            event.preventDefault();\n        }\n    }\n\n    function triggerEvent(eventName) {\n        let event;\n        const OPTIONS = {\n            header: header,\n            hamburger: hamburger,\n            navigation: navigation,\n            focusable: focusable,\n            focusableNav: focusableNav,\n            select: select\n        };\n        if (window.CustomEvent) {\n            event = new CustomEvent(eventName, { detail: OPTIONS });\n        } else {\n            event = document.createEvent(\"CustomEvent\");\n            event.initCustomEvent(eventName, true, true, OPTIONS);\n        }\n        document.dispatchEvent(event);\n    }\n\n    function hideMenu(setIndex = true) {\n        menuIsOpen = false;\n        if (setIndex) {\n            setTabIndexFromNavigationElements(false);\n        }\n        DEFAULTS.body.classList.remove(menuOpen);\n        window.scrollTo(0, parseInt(DEFAULTS.body.style.top) * -1);\n        DEFAULTS.body.style.top = \"\";\n\n        // Remove events\n        try {\n            Gator(DEFAULTS.body).off(\"focus\", maintainFocus);\n        } catch (error) {}\n        try {\n            Gator(document).off(\"keydown\", bindKeypress);\n        } catch (error) {}\n\n        triggerEvent(\"mobileMenu.close\");\n    }\n\n    function showMenu() {\n        menuIsOpen = true;\n\n        setTabIndexFromNavigationElements(true);\n        DEFAULTS.body.style.top = `-${window.pageYOffset}px`;\n        DEFAULTS.body.classList.add(menuOpen);\n\n        // Add events\n        Gator(DEFAULTS.body).on(\"focus\", maintainFocus);\n        Gator(document).on(\"keydown\", bindKeypress);\n\n        triggerEvent(\"mobileMenu.open\");\n    }\n\n    function toggleMenu() {\n        return menuIsOpen ? hideMenu() : showMenu();\n    }\n}\n","export default function(callback) {\n    let firstRun = true;\n\n    function runCallback(event) {\n        if (firstRun) {\n            if (typeof callback == \"function\") {\n                callback(event);\n            }\n            firstRun = false;\n        }\n    }\n\n    if (document.readyState == \"loading\") {\n        document.addEventListener(\"readystatechange\", runCallback);\n    } else {\n        runCallback();\n    }\n}\n","import matches from \"./matches\";\nimport isNode from \"./isNode\";\n\nexport default function(\n    element,\n    selectorOrElement = document.documentElement,\n    returnAll = false\n) {\n    const IS_STRING = typeof selectorOrElement == \"string\";\n\n    if (\n        !element ||\n        element.nodeType != 1 ||\n        (!IS_STRING && !isNode(selectorOrElement))\n    ) {\n        console.warn(\"Wrong or missing arguments in function `bubbleUntil`\");\n        return null;\n    }\n\n    let elements = [element];\n\n    while (\n        IS_STRING\n            ? !matches(element, selectorOrElement)\n            : element != selectorOrElement\n    ) {\n        element = element.parentNode;\n        elements.push(element);\n        if (!isNode(element)) {\n            return false;\n        }\n    }\n    return returnAll ? elements : element;\n}\n","// https://github.com/jonathantneal/focus-within/blob/master/index.js\n\nexport default function focusWithin(document, opts) {\n    const { className = \"\", attr = \"focus-within\", force } = Object(opts);\n    const lastElements = [];\n\n    try {\n        document.querySelector(\":focus-within\");\n\n        if (!force) {\n            return initialize;\n        }\n    } catch (ignoredError) {\n        /* do nothing */\n    }\n\n    function onfocuschange() {\n        let lastElement;\n\n        while ((lastElement = lastElements.pop())) {\n            if (attr) {\n                lastElement.removeAttribute(attr);\n            }\n\n            if (className) {\n                lastElement.classList.remove(className);\n            }\n        }\n\n        let activeElement = document.activeElement;\n\n        // only add focus if it has not been added and is not the document element\n        if (!/^(#document|HTML|BODY)$/.test(Object(activeElement).nodeName)) {\n            while (activeElement && activeElement.nodeType === 1) {\n                if (attr) {\n                    activeElement.setAttribute(attr, \"\");\n                }\n\n                if (className) {\n                    activeElement.classList.add(className);\n                }\n\n                lastElements.push(activeElement);\n\n                activeElement = activeElement.parentNode;\n            }\n        }\n    }\n\n    function initialize() {\n        document.addEventListener(\"focus\", onfocuschange, true);\n        document.addEventListener(\"blur\", onfocuschange, true);\n    }\n\n    /**\n     * Callback wrapper for check loaded state\n     */\n    /* eslint-disable */\n    !(function load() {\n        if (/m/.test(document.readyState)) {\n            document.removeEventListener(\"readystatechange\", load) |\n                initialize();\n        } else {\n            document.addEventListener(\"readystatechange\", load);\n        }\n    })();\n    /* eslint-enable */\n\n    return initialize;\n}\n","import mobileMenu from \"./Scripts/mobileMenu\";\n\nmobileMenu();\n"]}